name: Deploy Org Guardrails DDB

on:
  # Trigger on pushes to TTRS branches for org guardrails related changes
  push:
    branches: ['TTRS-*']
    paths: 
      - 'infrastructure/org-ddb/**'
      - 'src/functions/org_gr_ddb/**'
  
  # Trigger on PR merges to main and prod for org guardrails related changes
  pull_request:
    types: [closed]
    branches: [main, prod]
    paths: 
      - 'infrastructure/org-ddb/**'
      - 'src/functions/org_gr_ddb/**'

permissions:
  contents: read
  id-token: write
  deployments: write
  checks: write
  pull-requests: write
  statuses: write

# Global environment variable
env:
  AWS_REGION: ap-southeast-2
  PYTHON_VERSION: '3.11'

jobs:
  setup-and-validate:
    name: Setup and Validation
    runs-on: default
    outputs:
      python-cache-key: ${{ steps.cache.outputs.cache-hit }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'

      - name: Cache Python dependencies
        id: cache
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/pip
            /opt/hostedtoolcache/Python
          key: ${{ runner.os }}-python-${{ env.PYTHON_VERSION }}-${{ hashFiles('**/requirements.txt', 'scripts/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-python-${{ env.PYTHON_VERSION }}-

      - name: Install all dependencies
        run: |
          echo "üîß Installing all dependencies..."
          pip3 install -i https://artifactory.internal.cba/api/pypi/org.python.pypi/simple/ --upgrade pip
          
          # Install script dependencies
          pip3 install -i https://artifactory.internal.cba/api/pypi/org.python.pypi/simple/ -r scripts/requirements.txt
          
          # Install testing requirements
          pip3 install -i https://artifactory.internal.cba/api/pypi/org.python.pypi/simple/ pytest>=7.0.0 pytest-cov>=4.0.0 moto>=4.2.0 coverage>=7.0.0
          
          # Install AWS Lambda Powertools and dependencies including xray-sdk
          pip3 install -i https://artifactory.internal.cba/api/pypi/org.python.pypi/simple/ boto3 botocore
          
          # Install package in development mode
          pip install -e .[test]
          
          echo "‚úÖ All dependencies installed"

      - name: Lint Python scripts
        run: |
          echo "üîç Linting Python scripts..."
          python -m py_compile scripts/*.py
          if [ -d src ]; then
            find src -name "*.py" -exec python -m py_compile {} \;
          fi
          echo "‚úÖ Python syntax validation completed"

      - name: Validate AWS Wrapper Script
        run: |
          echo "‚úÖ Validating AWS wrapper script..."
          python scripts/aws_wrapper.py --help
          
          # Set PYTHONPATH to include current directory for module imports
          export PYTHONPATH=$PYTHONPATH:$(pwd)
          
          # Test deployment bucket validation script
          python -c "import scripts.validate_deployment_bucket; print('validate_deployment_bucket module loads successfully')"
          
          # Test stack status verification script
          python -c "import scripts.verify_stack_status; print('verify_stack_status module loads successfully')"
          
          # Test DynamoDB population script
          python -c "import scripts.populate_dynamodb; print('populate_dynamodb module loads successfully')"
          
          echo "‚úÖ Script functionality validation completed"

  run-unit-tests:
    name: Unit Tests with Coverage
    runs-on: default
    needs: [setup-and-validate]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'

      - name: Restore Python dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/pip
            /opt/hostedtoolcache/Python
          key: ${{ runner.os }}-python-${{ env.PYTHON_VERSION }}-${{ hashFiles('**/requirements.txt', 'scripts/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-python-${{ env.PYTHON_VERSION }}-

      - name: Install dependencies
        run: |
          echo "üîß Installing dependencies..."
          pip3 install -i https://artifactory.internal.cba/api/pypi/org.python.pypi/simple/ --upgrade pip
          pip3 install -i https://artifactory.internal.cba/api/pypi/org.python.pypi/simple/ -r scripts/requirements.txt
          pip3 install -i https://artifactory.internal.cba/api/pypi/org.python.pypi/simple/ pytest>=7.0.0 pytest-cov>=4.0.0 moto>=4.2.0 coverage>=7.0.0
          pip3 install -i https://artifactory.internal.cba/api/pypi/org.python.pypi/simple/ boto3 botocore
          
          # Install package in development mode
          pip install -e .[test]
          
          echo "‚úÖ Dependencies installed"

      - name: üß™ Run tests with coverage
        run: |
          echo "===================================================="
          echo "üß™ Running tests with coverage"
          echo "===================================================="
          mkdir -p test-reports
          
          # Set up environment
          export PYTHONPATH=$PYTHONPATH:$(pwd)
          export TABLE_NAME="test-org-guardrails-table"
          export AWS_DEFAULT_REGION="${{ env.AWS_REGION }}"
          
          # Run tests with coverage for org guardrails components
          pytest tests/org_gr_ddb/ \
            --cov=src/functions/org_gr_ddb \
            --cov-report=xml:test-reports/coverage.xml \
            --cov-report=term-missing \
            --cov-report=html:test-reports/htmlcov \
            --junit-xml=test-reports/junit.xml \
            --log-file=test-reports/logs.txt \
            -v --tb=short \
            --cov-fail-under=50 || echo "‚ö†Ô∏è Some tests failed or coverage below threshold"
          
          echo "‚úÖ Tests completed!"

      - name: üìä Upload test coverage reports
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: org-guardrails-test-reports
          path: test-reports/
          retention-days: 7

      - name: üìã Publish test results
        uses: dorny/test-reporter@v1
        if: always()
        with:
          name: Org Guardrails Pytest Results
          path: test-reports/junit.xml
          reporter: java-junit

      - name: üìä Display coverage summary
        if: always()
        run: |
          echo "===================================================="
          echo "üìä Test Coverage Summary"
          echo "===================================================="
          if [ -f "test-reports/coverage.xml" ]; then
            # Extract coverage percentage from XML using grep and sed
            COVERAGE=$(grep -o 'line-rate="[0-9.]*"' test-reports/coverage.xml | head -1 | grep -o '[0-9.]*' | awk '{printf "%.2f", $1*100}')
            echo "üîç Code Coverage: ${COVERAGE}%"
            
            # Coverage assessment using bc for comparison
            if command -v bc >/dev/null 2>&1; then
              if (( $(echo "${COVERAGE} >= 80" | bc -l) )); then
                echo "üèÜ Excellent coverage!"
              elif (( $(echo "${COVERAGE} >= 60" | bc -l) )); then
                echo "üëç Good coverage!"
              elif (( $(echo "${COVERAGE} >= 50" | bc -l) )); then
                echo "üëå Acceptable coverage."
              else
                echo "‚ö†Ô∏è Coverage below minimum threshold."
              fi
            else
              echo "üìä Coverage: ${COVERAGE}% (assessment requires bc package)"
            fi
          else
            echo "‚ö†Ô∏è No coverage report found"
          fi
          echo "===================================================="

  determine-environment:
    name: Determine Environment
    runs-on: default
    needs: [setup-and-validate, run-unit-tests]
    outputs:
      env_name: ${{ steps.set-env.outputs.env_name }}
    steps:
      - name: Determine Environment
        id: set-env
        run: |
          env_name="dev"
          if [[ "${{ github.event_name }}" == "pull_request" && "${{ github.event.pull_request.merged }}" == "true" ]]; then
            if [[ "${{ github.base_ref }}" == "prod" ]]; then
              env_name="prod"
            else
              env_name="nonp"
            fi
          fi
          echo "env_name=$env_name" >> $GITHUB_OUTPUT
          echo "üåç Environment determined: $env_name"

  deploy-org-guardrails:
    name: Deploy Org Guardrails DDB
    runs-on: default
    needs: [setup-and-validate, run-unit-tests, determine-environment]
    environment: ${{ needs.determine-environment.outputs.env_name }}
    strategy:
      matrix:
        include:
          # Org Guardrails tables
          - policy_type: "org"
            service_type: "guardrails"
            template_dir: "org-ddb"
            env_suffix: "preview"
            table_name: "org-guardrails-preview"
            stack_name: "prp-org-guardrails-policies-preview"
            job_name: "org-gr preview in dev"
          - policy_type: "org"
            service_type: "guardrails"
            template_dir: "org-ddb"
            env_suffix: "nonp"
            table_name: "org-guardrails-nonp"
            stack_name: "prp-org-guardrails-policies-nonp"
            job_name: "org-gr nonp in dev"
          - policy_type: "org"
            service_type: "guardrails"
            template_dir: "org-ddb"
            env_suffix: "prod"
            table_name: "org-guardrails-prod"
            stack_name: "prp-org-guardrails-policies-prod"
            job_name: "org-gr prod in dev"
      fail-fast: false

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'

      - name: Restore Python dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/pip
            /opt/hostedtoolcache/Python
          key: ${{ runner.os }}-python-${{ env.PYTHON_VERSION }}-${{ hashFiles('**/requirements.txt', 'scripts/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-python-${{ env.PYTHON_VERSION }}-

      # Configure AWS credentials using OIDC
      - name: Configure AWS credentials (AssumeRoleWithWebIdentity)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.GHA_TRUST_ROLE }}
          role-session-name: "GitHubActions"
          aws-region: ${{ env.AWS_REGION }}

      # Chain additional AWS role for CI/CD permissions
      - name: Configure AWS credentials (AssumeRole)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.GHA_CICD_ROLE }}
          role-session-name: "GitHubActions"
          aws-region: ${{ env.AWS_REGION }}
          role-chaining: true

      - name: Install dependencies
        run: |
          echo "üîß Installing dependencies..."
          pip3 install -i https://artifactory.internal.cba/api/pypi/org.python.pypi/simple/ --upgrade pip
          pip3 install -i https://artifactory.internal.cba/api/pypi/org.python.pypi/simple/ -r scripts/requirements.txt
          pip3 install -i https://artifactory.internal.cba/api/pypi/org.python.pypi/simple/ boto3 botocore
          
          echo "üîß Installing AWS SAM CLI..."
          # Try installing from Artifactory first, then fallback to public PyPI
          pip3 install -i https://artifactory.internal.cba/api/pypi/org.python.pypi/simple/ aws-sam-cli || pip3 install aws-sam-cli
          
          # Verify installation
          if ! command -v sam &> /dev/null; then
            echo "‚ö†Ô∏è SAM CLI not available via pip, installing from GitHub..."
            wget -q https://github.com/aws/aws-sam-cli/releases/latest/download/aws-sam-cli-linux-x86_64.zip
            unzip -q aws-sam-cli-linux-x86_64.zip -d sam-installation
            sudo ./sam-installation/install
          fi
          
          sam --version
          echo "‚úÖ All dependencies installed successfully"

      - name: Check AWS Identity
        run: |
          echo "Current AWS identity:"
          python scripts/aws_wrapper.py sts get-caller-identity --region ${{ env.AWS_REGION }}

      - name: Setup Environment Variables
        run: |
          export SAM_CLI_TELEMETRY=0
          export AWS_PAGER=""
          echo "SAM_CLI_TELEMETRY=0" >> $GITHUB_ENV
          echo "AWS_PAGER=" >> $GITHUB_ENV

      - name: Validate deployment bucket
        run: |
          # Set the bucket name from GitHub variables
          DEPLOYMENT_BUCKET="${{ vars.BUCKET_NAME }}"
          
          if [[ -z "${DEPLOYMENT_BUCKET}" ]]; then
            echo "Error: BUCKET_NAME variable is not set in GitHub repository variables."
            echo "Please add BUCKET_NAME as a repository or environment variable."
            exit 1
          fi
          
          # Run the Python script to validate the deployment bucket
          python scripts/validate_deployment_bucket.py \
            --bucket-name "$DEPLOYMENT_BUCKET" \
            --region "${{ env.AWS_REGION }}" \
            --export-env

      - name: Validate SAM Template
        run: |
          echo "Validating ${{ matrix.policy_type }}-${{ matrix.service_type }} template"
          if ! sam validate --template infrastructure/${{ matrix.template_dir }}/template.yaml --region ${{ env.AWS_REGION }}; then
            echo "‚ùå SAM template validation failed"
            exit 1
          fi
          echo "‚úÖ SAM template validation successful"

      - name: üèóÔ∏è Build with SAM
        run: |
          echo "===================================================="
          echo "üèóÔ∏è Building ${{ matrix.policy_type }}-${{ matrix.service_type }} policy stack"
          echo "===================================================="
          
          # Set environment variables for build
          export PIP_INDEX_URL="https://artifactory.internal.cba/api/pypi/org.python.pypi/simple/"
          export PIP_TRUSTED_HOST="artifactory.internal.cba"
          
          # Change to the policy-specific directory
          cd infrastructure/${{ matrix.template_dir }}
          
          # Build the SAM application with optimizations
          if ! sam build \
            --template-file template.yaml \
            --build-dir .aws-sam/build \
            --cache-dir .aws-sam/cache \
            --parallel \
            --cached \
            --use-container \
            --manifest "*.py,config/**/*.py,models/**/*.py,services/**/*.py,utils/**/*.py,requirements.txt"; then
            echo "‚ùå SAM build failed"
            exit 1
          fi
          echo "‚úÖ SAM build completed successfully!"

      - name: List build directory contents
        run: |
          ls -lR infrastructure/${{ matrix.template_dir }}/.aws-sam/build

      - name: üì§ Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: sam-build-artifacts-org-guardrails-${{ matrix.env_suffix }}-${{ github.run_id }}
          path: |
            infrastructure/${{ matrix.template_dir }}/.aws-sam/build/
            infrastructure/${{ matrix.template_dir }}/.aws-sam/cache/
          retention-days: 1

      - name: Clean SAM build artifacts
        if: always()  # Run even if previous steps fail
        run: |
          echo "Cleaning up SAM build artifacts..."
          # Clean build artifacts
          rm -rf infrastructure/${{ matrix.template_dir }}/.aws-sam/build
          rm -rf infrastructure/${{ matrix.template_dir }}/.aws-sam/cache
          # Clean generated templates
          rm -f infrastructure/${{ matrix.template_dir }}/packaged-template.yaml
          rm -f infrastructure/${{ matrix.template_dir }}/.aws-sam/build.toml
          # Clean any temporary files
          find infrastructure/${{ matrix.template_dir }} -name "*.tmp" -delete
          find infrastructure/${{ matrix.template_dir }} -name "*.bak" -delete
          echo "‚úÖ Cleanup completed"

      - name: Deploy SAM Application
        run: |
          export SAM_CLI_TELEMETRY=0
          export AWS_PAGER=

          # Define key variables using matrix values
          STACK_NAME="${{ matrix.stack_name }}"
          TABLE_NAME="${{ matrix.table_name }}"
          
          echo "üìã Environment-specific configuration:"
          echo "  - Stack: ${STACK_NAME}"
          echo "  - Table: ${TABLE_NAME}"
          echo "  - Environment: ${{ matrix.env_suffix }}"

          # Check if stack is still in DELETE_FAILED state after cleanup
          STACK_STATUS=$(python scripts/aws_wrapper.py cloudformation describe-stacks --stack-name $STACK_NAME --region ${{ env.AWS_REGION }} 2>/dev/null || echo "DOES_NOT_EXIST")

          if [[ "$STACK_STATUS" == "DELETE_FAILED" ]]; then
            echo "ERROR: Stack $STACK_NAME is still in DELETE_FAILED state after cleanup attempts. Cannot proceed with deployment."
            exit 1
          fi

          echo "Deploying ${{ matrix.policy_type }}-${{ matrix.service_type }} policy stack..."

          # Change to the policy-specific directory
          cd infrastructure/${{ matrix.template_dir }}

          # Package the built artifacts
          echo "Packaging artifacts..."
          sam package \
            --s3-bucket ${{ env.DEPLOYMENT_BUCKET }} \
            --s3-prefix lambda/${{ matrix.policy_type }}/${{ matrix.service_type }}/$(date +%Y%m%d-%H%M%S) \
            --template-file .aws-sam/build/template.yaml \
            --output-template-file packaged-template.yaml \
            --region ${{ env.AWS_REGION }}
          
          echo "Deploying stack..."
          MAX_RETRIES=3
          RETRY_COUNT=0
          BACKOFF_TIME=30
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo "Deployment attempt $((RETRY_COUNT + 1))/$MAX_RETRIES"
            
            # Deploy with SAM
            if sam deploy \
              --template-file packaged-template.yaml \
              --stack-name ${STACK_NAME} \
              --parameter-overrides \
                  Environment=${{ matrix.env_suffix }} \
                  OrganizationId=${{ vars.ORGANIZATION_ID }} \
              --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM CAPABILITY_AUTO_EXPAND \
              --no-fail-on-empty-changeset \
              --region ${{ env.AWS_REGION }} \
              --on-failure ROLLBACK \
              --tags \
                  Environment=${{ matrix.env_suffix }} \
                  PolicyType=${{ matrix.policy_type }} \
                  ServiceType=${{ matrix.service_type }} \
                  ManagedBy=GitHubActions \
                  LastDeployedAt=$(date -u +"%Y-%m-%dT%H:%M:%SZ"); then
              
              # Verify stack status after deployment
              STACK_STATUS=$(python scripts/verify_stack_status.py \
                --stack-name "$STACK_NAME" \
                --region "${{ env.AWS_REGION }}" \
                --show-info --output-status)
              
              if [[ "$STACK_STATUS" == "CREATE_COMPLETE" || "$STACK_STATUS" == "UPDATE_COMPLETE" ]]; then
                echo "‚úÖ Deployment successful and stack is in good state"
                break
              else
                echo "‚ö†Ô∏è Stack deployment completed but status is $STACK_STATUS"
                RETRY_COUNT=$((RETRY_COUNT + 1))
              fi
            else
              DEPLOY_EXIT_CODE=$?
              RETRY_COUNT=$((RETRY_COUNT + 1))
              echo "‚ö†Ô∏è Deployment failed with exit code $DEPLOY_EXIT_CODE. Retry $RETRY_COUNT/$MAX_RETRIES"
              
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "Waiting $BACKOFF_TIME seconds before retry..."
                sleep $BACKOFF_TIME
                BACKOFF_TIME=$((BACKOFF_TIME * 2))  # Exponential backoff
              fi
            fi
          done
          
          if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
            echo "‚ùå Deployment failed after $MAX_RETRIES attempts"
            # Cleanup on failure
            rm -f packaged-template.yaml
            exit 1
          fi

          echo "‚úÖ SAM deployment completed successfully"

      - name: Populate DynamoDB Table
        run: |
          TABLE_NAME="${{ matrix.table_name }}"
          echo "Populating table: $TABLE_NAME"
          
          # Use Python script to populate table
          python scripts/populate_dynamodb.py \
            --table-name "$TABLE_NAME" \
            --policy-type "${{ matrix.policy_type }}" \
            --region "${{ env.AWS_REGION }}"

          echo "‚úÖ DynamoDB population completed for $TABLE_NAME"

      # === VERIFICATION STEPS ===
      - name: Check Stack Status and Resources
        run: |
          echo "üîç Verifying stack deployment status and resources..."
          
          STACK_NAME="${{ matrix.stack_name }}"
          
          # Use Python script to verify stack status with detailed checks
          if ! python scripts/verify_stack_status.py \
            --stack-name "$STACK_NAME" \
            --region "${{ env.AWS_REGION }}" \
            --show-info \
            --check-resources \
            --wait-stable; then
            echo "‚ùå Stack verification failed"
            exit 1
          fi
          
          echo "‚úÖ Stack status and resources verification completed"

      - name: Verify Table Data
        run: |
          TABLE_NAME="${{ matrix.table_name }}"
          echo "Checking data in table: $TABLE_NAME"

          # Check if table exists using AWS wrapper
          if ! python scripts/aws_wrapper.py dynamodb describe-table --table-name "$TABLE_NAME" --region "${{ env.AWS_REGION }}" >/dev/null 2>&1; then
            echo "‚ùå Table $TABLE_NAME does not exist"
            exit 1
          fi

          echo "‚úÖ Table $TABLE_NAME exists"

          # Use Python script to check table data
          python scripts/populate_dynamodb.py \
            --table-name "$TABLE_NAME" \
            --policy-type "${{ matrix.policy_type }}" \
            --region "${{ env.AWS_REGION }}" \
            --check-only

          echo "‚úÖ Table verification completed for $TABLE_NAME"
